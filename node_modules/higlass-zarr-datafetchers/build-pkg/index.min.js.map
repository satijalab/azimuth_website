{"version":3,"file":"index.min.js","sources":["../src/ZarrMultivecDataFetcher.js"],"sourcesContent":["import { HTTPStore, openArray, slice } from 'zarr';\n\nfunction multivecChunksToTileDenseArray(chunks, tileShape, isRow) {\n  // Allocate a Float32Array for the tile (with length tile_size).\n  const fullTileLength = (isRow ? tileShape[1] : tileShape[0] * tileShape[1]);\n  const fullTileArray = new Float32Array(fullTileLength);\n\n  // Fill in the data for each sample and chunk.\n  let offset = 0;\n  if(isRow) {\n    // Single row, no need to iterate over samples.\n    for (const chunk of chunks) {\n      const chunkData = chunk.data;\n      fullTileArray.set(chunkData, offset);\n      offset += chunkData.length;\n    }\n  } else {\n    // Multi-row, need to iterate over samples.\n    const numSamples = tileShape[0];\n    for (let sampleI = 0; sampleI < numSamples; sampleI++) {\n      for (const chunk of chunks) {\n        const chunkData = chunk.data[sampleI];\n        fullTileArray.set(chunkData, offset);\n        offset += chunkData.length;\n      }\n    }\n  }\n  \n  return fullTileArray;\n}\n\nconst ZarrMultivecDataFetcher = function ZarrMultivecDataFetcher(HGC, ...args) {\n\n  if (!new.target) {\n        throw new Error(\n          'Uncaught TypeError: Class constructor cannot be invoked without \"new\"',\n        );\n    }\n\n    const { slugid } = HGC.libraries;\n    const {\n      absToChr,\n      parseChromsizesRows,\n      genomicRangeToChromosomeChunks,\n      DenseDataExtrema1D,\n      minNonZero,\n      maxNonZero,\n    } = HGC.utils;\n\n    class ZarrMultivecDataFetcherClass {\n        constructor(dataConfig) {\n            this.dataConfig = dataConfig;\n            this.trackUid = slugid.nice();\n        \n            if (dataConfig.url) {\n              // console.assert(dataConfig.url.endsWith('.zarr'));\n              // S3 bucket must have a CORS policy to allow reading from any origin.\n              this.store = new HTTPStore(dataConfig.url);\n            }\n\n            if(dataConfig.row !== undefined) {\n              this.row = dataConfig.row;\n            }\n        }\n\n        tilesetInfo(callback) {\n            this.tilesetInfoLoading = true;\n        \n            // Use the tileset_info stored as JSON in file.zarr/.zattrs\n            return this.store\n              .getItem('.zattrs')\n              .then(bytes => {\n                const decoder = new TextDecoder('utf-8');\n                const json = JSON.parse(decoder.decode(bytes));\n                return json;\n              })\n              .then(attrs => {\n                this.tilesetInfoLoading = false;\n\n                const chromSizes = attrs.multiscales.map(d => ([d.name, d.metadata.chromsize]));\n                \n                const finalChrom = attrs.multiscales[attrs.multiscales.length - 1];\n                const maxPos = finalChrom.metadata.chromoffset + finalChrom.metadata.chromsize;\n                const tileSize = attrs.shape[1];\n                const retVal = {\n                  ...attrs,\n                  shape: [attrs.shape[1], attrs.shape[0]],\n                  chromSizes,\n                  tile_size: tileSize,\n                  max_width: maxPos,\n                  min_pos: [0],\n                  max_pos: [maxPos],\n                  max_zoom: Math.ceil(Math.log(maxPos / tileSize) / Math.log(2)),\n                };\n        \n                if (callback) {\n                  callback(retVal);\n                }\n        \n                return retVal;\n              })\n              .catch(err => {\n                this.tilesetInfoLoading = false;\n        \n                if (callback) {\n                  callback({\n                    error: `Error parsing zarr multivec: ${err}`,\n                  });\n                }\n              });\n          }\n        \n          fetchTilesDebounced(receivedTiles, tileIds) {\n            const tiles = {};\n        \n            const validTileIds = [];\n            const tilePromises = [];\n        \n            for (const tileId of tileIds) {\n              const parts = tileId.split('.');\n              const z = parseInt(parts[0], 10);\n              const x = parseInt(parts[1], 10);\n        \n              if (Number.isNaN(x) || Number.isNaN(z)) {\n                console.warn('Invalid tile zoom or position:', z, x);\n                continue;\n              }\n        \n              validTileIds.push(tileId);\n              tilePromises.push(this.tile(z, x, tileId));\n            }\n        \n            Promise.all(tilePromises).then(values => {\n              for (let i = 0; i < values.length; i++) {\n                const validTileId = validTileIds[i];\n                tiles[validTileId] = values[i];\n                tiles[validTileId].tilePositionId = validTileId;\n              }\n              receivedTiles(tiles);\n            });\n            return tiles;\n          }\n        \n          tile(z, x, tileId) {\n            const { store } = this;\n            return this.tilesetInfo().then(tsInfo => {\n              // const multiscales = tsInfo.multiscales;\n        \n              // Adapted from clodius.tiles.multivec.get_single_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L66\n        \n              // z is the index of the resolution that should be selected.\n              // Resolution is size of each bin (except for the last bin in each chromosome).\n              const resolution = +tsInfo.resolutions[z];\n              const tileSize = +tsInfo.tile_size;\n              const binSize = resolution;\n        \n              // Where in the data does the tile start and end?\n              const tileStart = x * tileSize * resolution;\n              const tileEnd = tileStart + tileSize * resolution;\n        \n              // chromSizes is an array of \"tuples\" [ [\"chr1\", 1000], ... ]\n              const chromSizes = tsInfo.chromSizes;\n        \n              // Adapted from clodius.tiles.multivec.get_tile\n              // Reference: https://github.com/higlass/clodius/blob/develop/clodius/tiles/multivec.py#L110\n\n              const chromInfo = parseChromsizesRows(chromSizes);\n              const [chrStart, chrStartPos] = absToChr(tileStart, chromInfo);\n              const [chrEnd, chrEndPos] = absToChr(tileEnd, chromInfo);\n              const genomicStart = { chr: chrStart, pos: chrStartPos };\n              const genomicEnd = { chr: chrEnd, pos: chrEndPos };\n        \n              // Using the [genomicStart, genomicEnd] range, get an array of \"chromosome chunks\",\n              // where each chunk range starts and ends with the same chromosome.\n              // Start a new chromosome chunk at each chromosome boundary.\n              const chrChunks = genomicRangeToChromosomeChunks(\n                chromSizes,\n                genomicStart,\n                genomicEnd,\n                binSize,\n                tileSize,\n              );\n        \n              // Get the zarr data for each chromosome chunk,\n              // since data for each chromosome is stored in a separate zarr array.\n              return Promise.all(\n                chrChunks.map(([chrName, zStart, zEnd]) => {\n                  return openArray({\n                    store,\n                    path: `/chromosomes/${chrName}/${resolution}/`,\n                    mode: 'r',\n                  }).then(arr => (this.row !== undefined\n                    ? arr.getRaw([this.row, slice(zStart, zEnd)])\n                    : arr.get([null, slice(zStart, zEnd)])\n                  ));\n                }),\n              ).then(chunks => {\n                const dense = multivecChunksToTileDenseArray(chunks, [tsInfo.shape[1], tsInfo.shape[0]], this.row !== undefined);\n                return Promise.resolve({\n                  dense,\n                  denseDataExtrema: new DenseDataExtrema1D(dense),\n                  dtype: 'float32',\n                  min_value: Math.min.apply(null, dense),\n                  max_value: Math.max.apply(null, dense),\n                  minNonZero: minNonZero(dense),\n                  maxNonZero: maxNonZero(dense),\n                  server: null,\n                  size: 1,\n                  shape: tsInfo.shape,\n                  tileId,\n                  tilePos: [x],\n                  tilePositionId: tileId,\n                  tilesetUid: null,\n                  zoomLevel: z,\n                });\n              });\n            });\n        }\n    } // end class\n    return new ZarrMultivecDataFetcherClass(...args);\n} // end function wrapper\n\n\nZarrMultivecDataFetcher.config = {\n    type: 'zarr-multivec',\n};\n\nexport default ZarrMultivecDataFetcher;\n"],"names":["multivecChunksToTileDenseArray","chunks","tileShape","isRow","fullTileLength","fullTileArray","Float32Array","offset","chunkData","data","set","length","numSamples","sampleI","ZarrMultivecDataFetcher","HGC","Error","slugid","libraries","utils","absToChr","parseChromsizesRows","genomicRangeToChromosomeChunks","DenseDataExtrema1D","minNonZero","maxNonZero","ZarrMultivecDataFetcherClass","dataConfig","trackUid","nice","url","store","HTTPStore","undefined","row","callback","tilesetInfoLoading","this","getItem","then","bytes","decoder","TextDecoder","JSON","parse","decode","attrs","_this","chromSizes","multiscales","map","d","name","metadata","chromsize","finalChrom","maxPos","chromoffset","tileSize","shape","retVal","tile_size","max_width","min_pos","max_pos","max_zoom","Math","ceil","log","err","error","receivedTiles","tileIds","tiles","validTileIds","tilePromises","tileId","parts","split","z","parseInt","x","Number","isNaN","console","warn","push","tile","Promise","all","values","i","validTileId","tilePositionId","tilesetInfo","tsInfo","resolution","resolutions","binSize","tileStart","tileEnd","chromInfo","chrStart","chrStartPos","chrEnd","chrEndPos","chrChunks","chr","pos","chrName","zStart","zEnd","openArray","path","mode","arr","_this2","getRaw","slice","get","dense","resolve","denseDataExtrema","dtype","min_value","min","apply","max_value","max","server","size","tilePos","tilesetUid","zoomLevel","args","config","type"],"mappings":"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"}